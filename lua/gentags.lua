local ctags = require("gentags.ctags")
local Path = require("plenary.path")

local M = {}
local config = {
  autostart = true,
  append_on_save = true,
  root_dir = vim.g.gentags_root_dir or vim.loop.cwd(),
  cache = {
    path = Path:new(vim.fn.stdpath("cache")):joinpath("tags"),
  },
  async = true,
  bin = "ctags",
  args = {
    -- "--extras=+r+q",
    -- "--exclude=.git",
    -- "--exclude=node_modules*",
    -- "--exclude=.mypy*",
    -- "--exclude=.pytest*",
    -- "--exclude=.ruff*",
    -- "--exclude=BUILD",
    -- "--exclude=vendor*",
    -- "--exclude=*.min.*",
  },
  -- generate filetype based tag
  lang_ft_map = {
    -- ["Python"] = { "python" },
    -- ["Lua"] = { "lua" },
    -- ["Vim"] = { "vim" },
    -- ["C,C++,CUDA"] = { "c", "cpp", "h", "cuda" },
    -- ["JavaScript"] = { "javascript" },
    -- ["Go"] = { "go" },
    -- ["Rust"] = { "rust" },
  },

  -- user settings
  lang_opt_map = {},

  -- autogenerated
  lang_tag_map = {},

  -- subdir mode: generate separate tags for each subdirectory
  subdir_mode = false,
  -- subdirectories to generate separate tags (relative to root_dir)
  subdirs = {},
  -- subdir tag map: subdir -> tag file path (autogenerated)
  subdir_tag_map = {},
  -- subdir dependencies: specify which subdirs should also include tags from other subdirs
  -- example: { ["qz_client_lua"] = { "qz_pub" }, ["qz_server"] = { "qz_pub" } }
  subdir_deps = {},
  -- max duplicates: remove duplicate tags exceeding this number (nil or 0 to disable)
  -- example: max_duplicates = 10 means keep at most 10 entries for each tag name
  max_duplicates = nil,
}

local au_group = vim.api.nvim_create_augroup("GenTags", { clear = true })

-- Get the subdirectory for a file path
local function get_subdir_for_file(filepath)
  local root = config.root_dir:expand()
  local file_path = Path:new(filepath):expand()

  -- Check if file is under root_dir
  if not file_path:find(root, 1, true) then
    return nil
  end

  -- Check each configured subdir
  for _, subdir in ipairs(config.subdirs) do
    local subdir_path = config.root_dir:joinpath(subdir):expand()
    if file_path:find(subdir_path, 1, true) then
      return subdir
    end
  end

  return nil
end

-- Get tag file for a subdirectory
local function get_tag_file_for_subdir(subdir, lang)
  if subdir and config.subdir_tag_map[subdir] then
    return config.subdir_tag_map[subdir][lang]
  end
  return config.lang_tag_map[lang]
end

-- Generate tags for a specific subdirectory
M.generate_subdir = function(subdir, lang, filepath)
  local tag_file = get_tag_file_for_subdir(subdir, lang)
  if not tag_file then
    return
  end

  local options_path = config.lang_opt_map[lang]
  local subdir_path = config.root_dir:joinpath(subdir)

  if filepath then
    -- Only update tags for the single file (append mode)
    ctags.generate(config, lang, tag_file, options_path, filepath)
  else
    -- Generate tags for the entire subdirectory
    ctags.generate_for_subdir(config, lang, tag_file, options_path, subdir_path)
  end
end

M.generate = function()
  local lang = nil
  local ft = vim.bo.filetype

  for key, fts in pairs(config.lang_ft_map) do
    for _, _ft in ipairs(fts) do
      if ft == _ft then
        lang = key
        break
      end
    end
  end
  if not lang then
    return
  end

  -- Handle subdir mode
  if config.subdir_mode then
    local filepath = vim.fn.expand("%:p")
    local subdir = get_subdir_for_file(filepath)
    if subdir then
      M.generate_subdir(subdir, lang, nil)
      return
    end
  end

  local tag_file = config.lang_tag_map[lang]
  local options_path = config.lang_opt_map[lang]
  ctags.generate(config, lang, tag_file, options_path)
end

-- Generate tags for all configured subdirs
M.generate_all_subdirs = function()
  for lang, _ in pairs(config.lang_ft_map) do
    for _, subdir in ipairs(config.subdirs) do
      M.generate_subdir(subdir, lang, nil)
    end
  end
end

M.enable = function()
  for lang, tag_file in pairs(config.lang_tag_map) do
    local ft = config.lang_ft_map[lang]
    local options_path = config.lang_opt_map[lang]

    -- init file
    vim.api.nvim_create_autocmd({ "FileType" }, {
      group = au_group,
      pattern = ft,
      once = true,
      callback = function()
        if config.subdir_mode then
          -- Generate for all subdirs
          for _, subdir in ipairs(config.subdirs) do
            local subdir_tag_file = get_tag_file_for_subdir(subdir, lang)
            if subdir_tag_file and not subdir_tag_file:exists() then
              M.generate_subdir(subdir, lang, nil)
            end
          end
        else
          if tag_file:exists() then
            return
          end
          ctags.generate(config, lang, tag_file, options_path)
        end
      end,
    })

    -- buffer append generated tagfile
    vim.api.nvim_create_autocmd({ "FileType" }, {
      group = au_group,
      pattern = ft,
      callback = function(args)
        local filepath = vim.fn.expand("%:p")

        if config.subdir_mode then
          -- Find matching subdir and set corresponding tags
          local subdir = get_subdir_for_file(filepath)
          if subdir then
            local subdir_tag_file = get_tag_file_for_subdir(subdir, lang)
            if subdir_tag_file then
              vim.cmd("setlocal tags+=" .. subdir_tag_file:expand())
            end
            -- Also add dependency tags
            local deps = config.subdir_deps[subdir]
            if deps then
              for _, dep_subdir in ipairs(deps) do
                local dep_tag_file = get_tag_file_for_subdir(dep_subdir, lang)
                if dep_tag_file then
                  vim.cmd("setlocal tags+=" .. dep_tag_file:expand())
                end
              end
            end
          else
            -- Fallback to root tags
            vim.cmd("setlocal tags+=" .. tag_file:expand())
          end
        else
          vim.cmd("setlocal tags+=" .. tag_file:expand())
        end

        -- append new tags to file
        vim.api.nvim_create_autocmd({ "BufWritePost", "FileWritePost" }, {
          group = au_group,
          buffer = args.buf,
          callback = function()
            local buf_filepath = vim.fn.expand("%:p")

            if config.subdir_mode then
              local subdir = get_subdir_for_file(buf_filepath)
              if subdir then
                M.generate_subdir(subdir, lang, buf_filepath)
                return
              end
            end

            ctags.generate(config, lang, tag_file, options_path, buf_filepath)
          end,
        })
      end,
    })
  end
end

M.disable = function()
  if au_group ~= nil then
    vim.api.nvim_del_augroup_by_id(au_group)
    au_group = vim.api.nvim_create_augroup("GenTags", { clear = true })
  end
end

local options_flag = "--options"
local options_flag_size = #options_flag

M.setup = function(args)
  if args == nil then
    args = {}
  end
  config = vim.tbl_deep_extend("keep", args, config)

  local root_path = Path:new(config.root_dir)
  config.root_dir = root_path
  Path:new(config.cache.path):mkdir({ exists_ok = true })

  if args.args ~= nil then
    for _, option in ipairs(args.args) do
      if option:sub(1, options_flag_size) == options_flag then
        config.has_options = true
        break
      end
    end
  end

  for lang_name, _ in pairs(config.lang_ft_map) do
    local tag_file = lang_name:gsub(",", "_") .. root_path:shorten():gsub(root_path._sep, "_"):gsub("%.", "")
    config.lang_tag_map[lang_name] = config.cache.path:joinpath(tag_file)
  end

  -- Setup subdir tag map
  if config.subdir_mode and #config.subdirs > 0 then
    for _, subdir in ipairs(config.subdirs) do
      config.subdir_tag_map[subdir] = {}
      for lang_name, _ in pairs(config.lang_ft_map) do
        local subdir_safe = subdir:gsub("[/\\]", "_"):gsub("%.", "")
        local tag_file = lang_name:gsub(",", "_") .. "_" .. root_path:shorten():gsub(root_path._sep, "_"):gsub("%.", "") .. "_" .. subdir_safe
        config.subdir_tag_map[subdir][lang_name] = config.cache.path:joinpath(tag_file)
      end
    end
  end

  if config.autostart then
    M.enable()
  end
end

return M